---
Author: Maxim Orlovsky
Status: Draft
Proposed: 10 Jul 2025
Revision: 1; 22 Jul 2025
License: CC-BY
---

# RGB-I.0 consensus

## 1. Introduction

RGB is a client-side validated distributed smart contracting system.
It leverages an UTXO-based distributed blockchain (so-called *layer 1*)
for reaching the finality of the state;
however, it doesn't use it for neither ordering of transactions nor for storing a state,
unlike all other smart contract systems.
Thus, layer 1 in strict computer science terms doesn't serve as an RGB consensus,
since it doesn't fulfill any of the properties defining a distributing consensus protocol:
- ordering of transactions (RGB transactions are not published or broadcasted via blockchain);
- state machine replication (no state is replicated via layer 1);
- atomic broadcasts (since the ordering of layer 1 transactions doesn't matter for RGB).

Instead, RGB runs its own _client-side validated consensus_, where blockchain consensus
acts just as one of the components. This protocol is described in this standard.

## 2. Used Notations

We use standard mathematical symbols, including symbols of set theory.
Ordering of elements in set is denoted with $\succ$ and $\prec$.
Terms are defined by $\triangleq$, sets are indexed by subscripts $s_i \in \mathcal{S}$,
logical conditions are done with $\land$ (AND), $\lor$ (OR) and $\lnot$ (NOT),
$\Longleftrightarrow$ is used for _if and only if_ condition,
$\nRightarrow$ for _else_, and $\perp$ is a program termination.

Scalar variables are given with Latin and Greek lowercase letters.
The may belong to natural numbers $\mathbb{N}$, integers $\mathbb{Z}$,
non-zero natural numbers $\mathbb{N}^+ \triangleq \mathbb{N}\setminus\{0\}$ or
be an element of a finite field $\mathbb{F}_q$ having order $q$.
The bit dimensions of scalars (except the finite field elements) are given as a subscript:
$\mathbb{N}_{256}$ with $\mathbb{N}_8 \triangleq \mathbb{N}_8$ used for both 8-bit 
unsigned integers and bytes.
Binary strings (scalar arrays) of fixed size are given using power notation,
for instance, $\mathbb{N}_8^{32}$ is a 32-byte string.
Boolean type is defined by a set $\mathbb{B} \triangleq \{0, 1\}$.

Tuples (ordered fixed-size set of objects of a different type) are denoted with angular brackets
$\langle \ldots \rangle$ to list the typle elements
and with small Latin serif letters (like $\mathsf{a}, \mathsf{x}$) to represent immutable values.

Multivalued tuples, which may change over time (tuple variables) are denoted
and with capital Latin or Greek serif letters (like $\mathsf{C}$). to represent
a sequence or individual tuple values which evolve over time (like state objects),
with individual values being a lower-case indexed version of the same letter
($\mathsf{c}_0, \mathsf{c}_i$, etc).

We use tuple name and serif index to represent a named element of a tuple,
like in $\mathsf{c}_i \triangleq \langle \mathsf{C_{Id}}, \ \ldots \rangle$.

Variable-size sets of the same-typed objects (ordered or unordered) are denoted with
calligraphic uppercase Latin letters (like $\mathcal{S}$).
For representing set elements we use braces $\{\ldots\}$ and [set builder notation].
The type of variable-sized sets is given as an element type with a power component
specifying the range of the allowed set cardinality.
For instance, $\mathbb{N}_8^{[0, 32)}$ indicates a sequence of bytes with cardinality (length)
in a range of $0$ to $2^{32} - 1$. Whether such sets are ordered (sequences) or unordered
is specified in the description, case by case. 

Unicode strings are represented as a sequence made of $\mathbb{U}$ set elements
(UTF-8 character set); ASCII strings as sequence made of $\mathbb{A}$ set elements.
If there are constraints on the type of ASCII characters which can be used in a string,
the constraint is either given verbally as an index (for instance, $\mathbb{A}_\mathsf{printable}$),
or as a wildcard $\mathbb{A}_*$ with detailed explanation of the constraints given in the text.

Functions with a well-defined algorithm are denoted by a serif Latin small-case names,
followed by a dot, function domain, arrow and function co-domain,
like $\mathsf{evaluate}: \mathcal{A} \rightarrow \mathcal{B}$.
Application of the function to arguments is written as $\mathsf{evaluate}(a_i)$.
Variables having a function type are written as small Greek letters in italic, $\phi$,
and their application as $\phi(x)$.
Inline functions depending on their previous values are defined using
$\mapsto$ instead of $\rightarrow$.

All numbers are encoded into and from a byte-strings with a little-endian convention.

## 3. Protocol Overview

In technical terms, RGB operates as is partially replicated state machines (PRiSM),
which uses polynomial computer architecture SONIC
(State machine with Ownership Notation Involving Capabilities).

_Partially replicated_ means that not all the state is replicated between the instances
of the state machine; instead, only a part of the state required by each of the instances
is propagated.

_Polynomial computer_ means that the trace of the operations by the consensus protocol
can be arithmetized to polynomials,
making it possible to use any zk-STARK prover for zero knowledge compression.

_Ownership notation involving capabilities_ means that some types of state in RGB 
are assigned to specific parties (actors), and this assignment is made using _capabilities_,
which are implemented using a single-use seal cryptographic scheme.

RGB consensus uses the following underlying components:
- SONIC polynomial computer (its consensus-related layer named "UltraSONIC")
  with capability-based memory and zk-AluVM virtual machine,
  used for contract state evaluation/validation;
- RGB contracts, their state and state transitions;
- commitment schemes, using cryptographic hash functions;
- single-use seals, for providing capabilities and for finality.

The version of RGB consensus described in this document is named **RGB-I.0**.
You can find more on RGB version numbering in [RGB-6] standard.

## 5. SONIC Architecture

TBD: Overview

### zk-AluVM Nachine

TBD

### Memory

The SONIC architecture used by RGB defines two types of the contract state:
- read-once memory,
- write-once memory.

.............

## 6. RGB Contracts

Contract is an instance of RGB protocol. RGB consensus operates on the contract level,
and doesn't include (as of version I.0) any cross-contract functionality[^1].

Since RGB operates as a partially-replicated state machine,
each party has a partial view over contracts, named **local contract**. 
A local contract is defined as

$$\mathsf{C} \triangleq \langle \mathsf{\Theta}, \mathcal{O} \setminus \{ \mathsf{c}_0 \} \rangle$$

where $\Theta$ is a contract issue and
$\mathcal{O}$ is the locally known part of the contract operations
(excluding genesis operation $\mathsf{c}_0$ already present in $\Theta$, see below).

The contract **issue** defines *unique* and *global* properties of a contract;
it must be known to all parties (i.e. present in each *local contract*) and
it is represented by a tuple

$$\mathsf{\Theta} \triangleq \langle v, \mathsf{m}, \mathsf{k}, \mathsf{c}_0 \rangle$$

| Symbol         | Type                                                                                                                                              | Value range  | Meaning                         |
|----------------|---------------------------------------------------------------------------------------------------------------------------------------------------|--------------|---------------------------------|
| $v$            | $\mathbb{N}_8$                                                                                                                                    | constant $0$ | RGB issue datastructure version |
| $\mathsf{m}$   | $\langle \mathbb{B}, \mathbb{N}_8, \mathbb{N}_{64}, \mathbb{B}^{48}, \mathbb{A}_*^{[1, 100)?}, \mathbb{A}_\mathsf{printable}^{[1, 4096)} \rangle$ | n/a          | Contract metadata               |
| $\mathsf{k}$   | tuple (see below)                                                                                                                                 | n/a          | Codex                           |
| $\mathsf{c}_0$ | tuple (see below)                                                                                                                                 | n/a          | Genesis operation               |

A commitment to the *issue* data represents a unique and global **contract id**
$\mathsf{Id}(\mathsf{C})$, or $\mathsf{C_{Id}}$.

The contract metadata $\mathsf{m}$ define contract-specific parameters, which include
(in the order of their position in the tuple):
1) boolean indicating whether the contract is a test contract,
2) a specific consensus layer 1 used by the contract,
3) ISO 8601 timestamp of the moment the contract is issued,
4) a set of feature flags (must be zeros for RGB-I.0),
5) optional name of the contract, which must start with a capital letter or a `_` symbol,
  and may contain up to 99 ASCII letters, numbers, or `_` symbols,
6) an identity string of the contract issuer, made of ASCII printable characters.

### Codex

Codex is a set of parameters and rules which define contract business logic 
but do not define any form of a state. The _contract business logic_ does not mean
the way how the state transitions are created; instead, it defines how an arbitrary
state transition, created with any possible rules, gets validated. If it passes the validation,
its business logic is valid; if it doesn't - it is not. This paves the way to a huge
scalability, as well as much more compact zk-STARK proofs; since any zk-proof just proves
a result of a computation, not specifying the exact way of performing the computation itself.
The mistake of blockchain developers was to put the actual state transition function into
the blockchain, which doesn't scale. Client-side validation, implemented in RGB, fixes that.

Thus, an RGB codex defines a state transition _validation_ functions,
which are differentiated by a state transition type:
one contract may have multiple forms of state transition,
which can be seen as mutating methods of the contract.

Next, a codex defines the following contract parameters:
- Specific finite field size, which defines finite field $\mathbb{F}_q$ order $q$ and
  bit dimensions for finite field type variables, denoted hereinafter as $\|q\|_\mathsf{bits}$;
- cryptographic hash function used in commitment schemes;
- specific single-use seal protocol, which also defines the subset of specific blockchain networks,
  and commitment schemes;
- specific blockchain.

More formally, codex is a tuple

$$\mathsf{k} \triangleq \langle v, n, d, t, f, q, \mathsf{\Gamma}, \mathsf{\Lambda}, V \rangle$$

| Symbol             | Type                                                                             | Value range                              | Meaning                                                                           |
|--------------------|----------------------------------------------------------------------------------|------------------------------------------|-----------------------------------------------------------------------------------|
| $v$                | $\mathbb{N}_8$                                                                   | constant $0$                             | RGB issue datastructure version                                                   |
| $n$                | $\mathbb{N}_8^{[0, 255]}$                                                        | n/a                                      | Contract name, parsed as Unicode UTF-8 string                                     |
| $t$                | $\mathbb{N}_{64}$                                                                | any                                      | ISO 8601 timestamp of codex creation                                              |
| $f$                | $\mathbb{B}^{32}$                                                                | constant $0$                             | Feature flags (must be zeros in RGB-I.0)                                          |
| $q$                | $\mathbb{Z}_q$                                                                   | $[0, \mathbb{Z}_q)$                      | Feature flags (must be zeros in RGB-I.0)                                          |
| $\mathsf{\Gamma}$  | $\langle \mathbb{B}, \mathbb{B}, \mathbb{N}_{64} \rangle$                        | n/a                                      | Configuration for a [zk-AluVM computing core] for state transition verification   |
| $\mathsf{\Lambda}$ | $\langle \mathbb{B}, \mathbb{B}, \mathbb{N}_{64} \rangle$                        | n/a                                      | Configuration for a [zk-AluVM computing core] for memory access lock verification |
| $V$                | $\mathbb{N}_{16} \rightarrow \langle \mathbb{N}_8^{32}, \mathbb{N}_{16} \rangle$ | Valid entry points into known AluVM libs | Entry points for verification functions using AluVM libs                          |

Configurations for a [zk-AluVM computing core] are 3-tuples, which values correspond to:
1. Boolean flag indicating whether a VM must halt on the first occurence of a failure;
2. Boolean indicating whether a complexity limit is set;
3. 64-bit natural number representing the complexity limit (of the #2 is set).

For the details on complexity limits, please address [AluVM documentation].

The same codex may be used by multiple contracts, in the same way as a class,
defined with a programming language, may instantiate multiple objects.

It is important to note that multiple contracts may re-use the same codex.
In this way, there appears a natural differentiation between contract issuers and codex developers,
with the former being specializing in financial services, assets, etc;
and the second being specialists in computer science.


### Contract State

A **local contract state** is fully defined by a set of its operations, $\mathcal{O}$.

Since RGB consensus needs to operate as a polynomial computer with a computation trace being
arithmetizable as a set of polynomial constraints, the state of a contract at the level of
consensus must be always represented by a mathematical construct
made of elements of the finite field $\mathbb{Z}_q$, defined in the [contract codex](#codex).
This state is not human-readable and must be processed using a specific ABIs and interfaces
to be read by humans; however, this part lies outside the consensus definition, belogiging
to the RGB standard library, defined in [RGB-1010] standard.

A contract memory is a tuple $\mathsf{C} \triangleq \langle \mathcal{D}, \mathcal{I} \rangle$,
consisting of destructible $\mathcal{D}$ and immutable $\mathcal{I}$ memory cells.

- The destructible memory cells represent a **read-once** type of memory,
  which is defined by contract operations destructible outputs and removed once accessed
  by any of the contract operations referencing it as one of its inputs.

- The immutable memory cells represent a **write-once multiple-access** type of memory,
  which is defined by contract operations immutable outputs,
  and accessed by contract operations immutable inputs.

Each memory cells has an **address**, which is defined


as a result of 
$\mathsf{evaluate}: \mathcal{O} \rightarrow \langle \mathcal{D}, \mathcal{I} \rangle$ procedure.


### Contract Operation

Contract operation is a tuple, $o_i \triangleq \langle \mathsf{c}_i, S_i, u_i \rangle$, consisting of:
- client-side information of contract state change, represented by a tuple $\mathsf{c}_i$;
- an unordered map of seal definitions performed by an operation,
  $S_i(x): y_x \in \mathcal{Y_i} \rightarrow s_x$, where $s_x$ is a seal definition;
- a seal closing witness information,
  which values must belong to a set of either unit value, or a specific witness $w_i$:
  $u_i \in \{ \varnothing, w_i \}$.

A client-side part of the operation is represented by a tuple

$$\mathsf{c}_i \triangleq \langle v, \mathsf{C_Id}, \phi, \lambda, \Upsilon, \mathcal{A}, \mathcal{B}, \mathcal{Y}, \mathcal{Z} \rangle$$

where

| Symbol          | Type                  | Element size                    | Max elements | Value range  | Meaning                                  |
|-----------------|-----------------------|---------------------------------|--------------|--------------|------------------------------------------|
| $v$             | scalar                | 8 bits                          | n/a          | constant $0$ | RGB consensus version                    |
| $\mathsf{C_Id}$ | scalar                | $\|q\|_\mathsf{bits}$           | n/a          | any          | Contract id                              |
| $\phi$          | scalar                | 16 bits                         | n/a          | any          | Call id                                  |
| $\lambda$       | scalar                | $\|q\|_\mathsf{bits}$           | n/a          | any          | Nonce                                    |
| $\Upsilon$      | scalar tuple          | $\|q\|_\mathsf{bits}$           | 4            | any          | Witness data                             |
| $\mathcal{A}$   | ordered set of tuples | $4\|q\|_\mathsf{bits}+256+16$   | $2^{16}-1$   | n/a          | Destructible memory refs (input)         |
| $\mathcal{B}$   | ordered set of tuples | $256+16$                        | $2^{16}-1$   | n/a          | Immutable memory refs (input)            |
| $\mathcal{Y}$   | ordered set of tuples | $9\|q\|_\mathsf{bits}+256+17$   | $2^{16}-1$   | n/a          | Destructible memory declaration (output) |
| $\mathcal{Z}$   | ordered set of tuples | $4\|q\|_\mathsf{bits}+variable$ | $2^{16}-1$   | n/a          | Immutable memory declaration (output)    |

Contract *genesis* is a special type of operation, containing no input:
$$\mathsf{c}_0 \triangleq \langle \pi, \mathsf{k_Id}, \phi, \lambda, \Upsilon, \varnothing, \varnothing, \mathcal{Y}, \mathcal{Z} \rangle$$


### Set of Operations

Each contract is defined by a partially ordered set of contract operations 
$\mathcal{O} \triangleq \{ o_i \}$.
An element of this set is a tuple, $o_i \triangleq \langle c_i, S_i, u_i \rangle$, consisting of:
- client-side information of contract state change, $c_i$;
- an unordered map of seal definitions performed by an operation, 
  $S_i: d_j \in \mathcal{Y}_i \rightarrow s_j$, where $s_j$ is a seal definition;
- a seal closing witness information, 
  which values must belong to a set of either unit value, or a specific witness $w_i$: 
  $u_i \in \{ \varnothing, w_i \}$.

The set $\mathcal{O}$ has an initial element, called **genesis** $o_1$, for which $u_i = \varnothing$.
There might be other operations for which $u_i = \varnothing$;
these operations are named _state extensions_.

All operations in $\mathcal{O}$ are partially ordered via rule

$$
o_i \prec o_j \Longleftrightarrow
(\exists \ y \in \mathcal{Y}_i: \mathsf{addr}(y) \in \mathcal{A}_j)
\vee
(\exists \ x \in \mathsf{X}_i: \mathsf{addr}(x) \in \mathsf{B}_j)
$$

which means that if there exists at least one output of $c_i$ which is used by $c_j$, or a global
state defined in $c_i$ which is read by $c_j$, than $o_i$ precedes $c_j$.

If the $\mathcal{O}$ is not a directed acyclic graph and the above rule can't be fulfilled without
collisions, the operation set must be recognized as invalid.

### Evaluate Procedure

The contract state is evaluated using the following $\mathsf{evaluate}$ procedure applied to the set of
contract operations:

$$
\forall o_i \in O:
(\forall \ a \in \mathcal{A}_i \ \exists! \ d \in \mathcal{D}_i: \mathsf{addr}(d) = a) \wedge \\
$$

$$
(\forall \ b \in \mathcal{B}_i \ \exists! \ e \in \mathcal{I}_i: \mathsf{addr}(e) = b) \wedge \\
$$

$$
\mathsf{verify}(w_i, \mathcal{Y}_i) \wedge \\
$$

$$
\mathsf{zk\_aluvm}(\mathcal{I}_i, \mathcal{D}_i, c_i) \\
$$

$$
\Longrightarrow \mathcal{D}_{i+1} \mapsto (\mathcal{D}_i \setminus \mathsf{A}_i) \cup \mathsf{output}(c_i); \\
$$

$$
\mathcal{I}_{i+1} \mapsto \mathcal{I}_i \cup \mathsf{global}(c_i) \\
$$

$$
\nRightarrow \perp
$$

The first part of the algorithm checks whether an operation is correct, and depending on the result
the contract state is either evolved (middle expression), or the further validation terminates.


## 7. Commitment Schemes

TBD

## 8. RGB on Bitcoin

### TxO-based single-use seals

TBD

### Deterministic bitcoin commitments

TBD

## 9. Security Assumptions

- The selected cryptographic hash function is collision-resistant;
- The used single-use seal protocol is secure.


## 10. Reference Implementation

The reference implementation is provided in repositories and libraries listed in the
in the "consensus" section of [RGB-3] standard.


## 11. Acknowledgements

TBD

[^1]: However, one may still achieve cross-contract interaction outside of the consensus layer,
      for instance using atomic swaps.

[RGB-3]: https://github.com/RGB-WG/RFC/blob/master/RGB-0003.md

[RGB-6]: https://github.com/RGB-WG/RFC/blob/master/RGB-0006.md

[RGB-1010]: https://github.com/RGB-WG/RFC/blob/master/RGB-01010.md

[set builder notation]: https://en.wikipedia.org/wiki/Set-builder_notation

[AluVM documentation]: https://docs.aluvm.org

[zk-AluVM computing core]: https://github.com/AluVM/aluvm/blob/master/src/core/core.rs#L144-L153
